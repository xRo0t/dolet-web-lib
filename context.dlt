# ============================================================================
# Context - Key-value storage for template rendering in Dolet Web Framework
# Requirements: 5.1, 5.2, 5.3
# ============================================================================

# Context struct - holds key-value pairs for template variables
# Uses dynamic array storage for keys and values
# Requirements: 5.1, 5.2, 5.3
struct Context:
    keys: i64 = 0       # Pointer to array of string pointers (keys)
    values: i64 = 0     # Pointer to array of string pointers (values)
    count: i32 = 0      # Current number of entries
    capacity: i32 = 0   # Maximum capacity
    
    # ========== Helper Functions ==========
    
    # Compare two strings for equality
    # Returns: 1 if equal, 0 if not
    static fun str_equals(a: str, b: str) -> i32:
        len_a: i64 = Memory.strlen(a)
        len_b: i64 = Memory.strlen(b)
        
        if len_a != len_b:
            return 0
        
        i: i64 = 0
        while i < len_a:
            c1: i8 = Memory.read_i8((a as i64) + i)
            c2: i8 = Memory.read_i8((b as i64) + i)
            if c1 != c2:
                return 0
            i = i + 1
        
        return 1
    
    # ========== Context Operations ==========
    
    # Create new empty context with default capacity
    # Returns: new Context instance
    # Requirements: 5.1
    static fun new() -> Context:
        ctx: Context = Context{}
        ctx.capacity = 16  # Default capacity of 16 entries
        ctx.count = 0
        # Allocate arrays for keys and values (8 bytes per pointer)
        ctx.keys = Memory.malloc((ctx.capacity * 8) as i64)
        ctx.values = Memory.malloc((ctx.capacity * 8) as i64)
        return ctx
    
    # Store a key-value pair in the context
    # If key already exists, updates the value
    # Requirements: 5.2
    fun set(key: str, value: str):
        # First check if key already exists
        i: i32 = 0
        while i < self.count:
            offset: i64 = (i as i64) * 8
            stored_key: str = Memory.read_i64(self.keys + offset) as str
            
            if Context.str_equals(key, stored_key) == 1:
                # Key exists, update value
                Memory.write_i64(self.values + offset, value as i64)
                return
            
            i = i + 1
        
        # Key doesn't exist, add new entry
        if self.count >= self.capacity:
            # Capacity exceeded, ignore (could reallocate in future)
            return
        
        # Calculate offset for new entry
        offset: i64 = (self.count as i64) * 8
        
        # Store key pointer
        Memory.write_i64(self.keys + offset, key as i64)
        
        # Store value pointer
        Memory.write_i64(self.values + offset, value as i64)
        
        self.count = self.count + 1
    
    # Retrieve value for a key
    # Returns: the stored value, or empty string if key not found
    # Requirements: 5.3
    fun get(key: str) -> str:
        i: i32 = 0
        while i < self.count:
            offset: i64 = (i as i64) * 8
            stored_key: str = Memory.read_i64(self.keys + offset) as str
            
            if Context.str_equals(key, stored_key) == 1:
                return Memory.read_i64(self.values + offset) as str
            
            i = i + 1
        
        # Not found - return empty string
        return ""
