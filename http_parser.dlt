# ============================================================================
# HttpParser - HTTP request parsing for Dolet Web Framework
# Internal module - uses NativeCall directly, does NOT import from net module
# Requirements: 3.1, 3.2, 3.3, 8.3
# ============================================================================

# Request struct - represents an HTTP request
# Requirements: 3.1, 3.4
struct Request:
    method: str = ""
    path: str = ""
    headers: i64 = 0        # pointer to headers storage (used for client socket)
    body: str = ""
    route_pattern: str = "" # matched route pattern for parameter extraction
    
    # Get URL parameter value by name
    # Uses the matched route pattern to extract parameter from path
    # Returns: parameter value string, or empty string if not found
    # Requirements: 3.4
    fun param(name: str) -> str:
        # If no route pattern is set, cannot extract parameters
        if Memory.strlen(self.route_pattern) == 0:
            return ""
        
        # Use WebRouter.extract_param to get the parameter value
        return WebRouter.extract_param(self.route_pattern, self.path, name)


# HttpParser struct - HTTP request parsing utilities
# Requirements: 3.1, 3.2, 3.3, 8.3
struct HttpParser:
    # ========== Helper Functions ==========
    
    # Find position of a character in string starting from offset
    # Returns: position of char, or -1 if not found
    # Requirements: 8.3
    static fun find_char(s: str, c: i32, start: i64) -> i64:
        len: i64 = Memory.strlen(s)
        pos: i64 = start
        while pos < len:
            ch: i32 = Memory.read_i8((s as i64) + pos) as i32
            if ch == c:
                return pos
            pos = pos + 1
        return -1
    
    # Find position of CRLF (\r\n) in string starting from offset
    # Returns: position of \r, or -1 if not found
    # Requirements: 8.3
    static fun find_crlf(s: str, start: i64) -> i64:
        len: i64 = Memory.strlen(s)
        pos: i64 = start
        while pos < len - 1:
            c1: i32 = Memory.read_i8((s as i64) + pos) as i32
            c2: i32 = Memory.read_i8((s as i64) + pos + 1) as i32
            # \r = 13, \n = 10
            if c1 == 13 and c2 == 10:
                return pos
            pos = pos + 1
        return -1
    
    # Find position of double CRLF (\r\n\r\n) - end of headers
    # Returns: position of first \r, or -1 if not found
    # Requirements: 8.3
    static fun find_header_end(s: str, start: i64) -> i64:
        len: i64 = Memory.strlen(s)
        pos: i64 = start
        while pos < len - 3:
            c1: i32 = Memory.read_i8((s as i64) + pos) as i32
            c2: i32 = Memory.read_i8((s as i64) + pos + 1) as i32
            c3: i32 = Memory.read_i8((s as i64) + pos + 2) as i32
            c4: i32 = Memory.read_i8((s as i64) + pos + 3) as i32
            if c1 == 13 and c2 == 10 and c3 == 13 and c4 == 10:
                return pos
            pos = pos + 1
        return -1

    
    # ========== HTTP Parsing ==========
    
    # Parse HTTP request from raw data
    # Returns: Request struct with method, path, headers, body
    # If malformed, returns Request with empty method (signals invalid request)
    # Requirements: 3.1, 3.2, 3.3, 8.3
    static fun parse(data: str) -> Request:
        req: Request = Request()
        
        # Check for empty or null data - handle gracefully
        # Requirements: 8.3
        data_len: i64 = Memory.strlen(data)
        if data_len == 0:
            return req
        
        # Find first space (after method)
        # HTTP request format: METHOD PATH HTTP/1.1\r\n
        space1: i64 = HttpParser.find_char(data, 32, 0)
        if space1 == -1:
            # Malformed - no space after method, return empty request
            # Requirements: 8.3
            return req
        
        # Extract method (e.g., "GET", "POST")
        # Requirements: 3.1
        req.method = Str.substring(data, 0, space1)
        
        # Find second space (after path)
        space2: i64 = HttpParser.find_char(data, 32, space1 + 1)
        if space2 == -1:
            # Try to find CRLF instead (path might be at end of line)
            crlf: i64 = HttpParser.find_crlf(data, space1 + 1)
            if crlf == -1:
                # No CRLF either, use rest of string as path
                req.path = Str.substring(data, space1 + 1, data_len)
                return req
            space2 = crlf
        
        # Extract path (e.g., "/api/users")
        # Requirements: 3.2
        req.path = Str.substring(data, space1 + 1, space2)
        
        # Find end of headers (double CRLF)
        header_end: i64 = HttpParser.find_header_end(data, 0)
        if header_end != -1:
            # Body starts after \r\n\r\n (4 bytes)
            body_start: i64 = header_end + 4
            if body_start < data_len:
                # Extract body content
                # Requirements: 3.3
                req.body = Str.substring(data, body_start, data_len)
            else:
                req.body = ""
        else:
            # No body found (valid case for GET requests)
            req.body = ""
        
        return req

